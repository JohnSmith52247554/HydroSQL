/**
 * @file affairs.hpp
 * @author username (username52247554@gmail.com)
 * @brief The result generated by the parser. Use to cache the parameter and execute the command.
 * @version 0.1
 * @date 2025-06-20
 *
 * @copyright Copyright (c) 2025
 *
 */

#include <affairs.hpp>

namespace HydroSQL::Server::Parser
{
    const int CreateTableA::execute(const std::unique_ptr<Authoriser> auth, std::string &result) const
    {
        result.clear();

        // check authority
        try
        {
            Engine::Table table(this->table_name, std::move(this->col));

            if (!Authority::AuthManager::get().addTable(table_name, auth->getUsername()))
            {
                return 0;
            }
            result = "[SUCCESS] Create table " + this->table_name + ".";
        }
        catch(const std::exception& e)
        {
            result = e.what();
            return 0;
        }
        return 1;
    }

    const int InsertA::execute(const std::unique_ptr<Authoriser> auth, std::string &result) const
    {
        result.clear();

        // check authority
        if (!auth->authorise(this->table_name, Authority::AuthLevel::MODIFY))
        {
            result = "[FAILED] Authority Insufficient.";
            return 0;
        }

        try
        {
            Engine::Table table(table_name);
            return table.insertV2(this->keys, this->values, result);
        }
        catch(const std::exception& e)
        {
            result = e.what();
            return 0;
        }
    }

    const int SelectA::execute(const std::unique_ptr<Authoriser> auth, std::string &result) const
    {
        result.clear();

        // check authority
        if (!auth->authorise(this->table_name, Authority::AuthLevel::READONLY))
        {
            result = "[FAILED] Authority Insufficient.";
            return 0;
        }

        try
        {
            Engine::Table table(table_name);
            std::vector<std::vector<std::string>> output;
            auto mark = table.select(this->keys, this->requirements, this->order, output, result);
            std::stringstream ss;
            ss << result << '\n';
            for (size_t i = 0; i < output.size(); i++)
            {
                for (const auto val : output[i])
                    ss << val << '\t';
                if (i != output.size() - 1)
                    ss << '\n';
            }
            
            result = ss.str();
            return mark;
        }
        catch (const std::exception &e)
        {
            result = e.what();
            return 0;
        }
    }

    const int UpdateA::execute(const std::unique_ptr<Authoriser> auth, std::string &result) const
    {
        result.clear();

        // check authority
        if (!auth->authorise(this->table_name, Authority::AuthLevel::MODIFY))
        {
            result = "[FAILED] Authority Insufficient.";
            return 0;
        }

        try
        {
            Engine::Table table(table_name);
            return table.updateV2(this->keys, this->expr, this->requirements, result);
        }
        catch (const std::exception &e)
        {
            result = e.what();
            return 0;
        }
    }

    const int DeleteA::execute(const std::unique_ptr<Authoriser> auth, std::string &result) const
    {
        result.clear();

        // check authority
        if (!auth->authorise(this->table_name, Authority::AuthLevel::MODIFY))
        {
            result = "[FAILED] Authority Insufficient.";
            return 0;
        }

        try
        {
            Engine::Table table(table_name);
            return table.delete_(this->requirements, result);
        }
        catch (const std::exception &e)
        {
            result = e.what();
            return 0;
        }
    }

    const int DropA::execute(const std::unique_ptr<Authoriser> auth, std::string &result) const
    {
        result.clear();

        // check authority
        if (!auth->authorise(this->table_name, Authority::AuthLevel::ADMIN))
        {
            result = "[FAILED] Authority Insufficient.";
            return 0;
        }

        try
        {
            Engine::Table table(table_name);
            if (!Authority::AuthManager::get().removeTable(table_name))
                return 0;
            return table.drop(result);
        }
        catch (const std::exception &e)
        {
            result = e.what();
            return 0;
        }
    }

    const int GrantA::execute(const std::unique_ptr<Authoriser> auth, std::string &result) const
    {
        result.clear();

        // check authority
        if (!auth->authorise(this->table_name, Authority::AuthLevel::ADMIN))
        {
            result = "[FAILED] Authority Insufficient.";
            return 0;
        }

        try
        {
            auto num = Authority::AuthManager::get().setUserAuth(this->user_list, this->table_name, this->level);
            result = "[SUCCESS] " + std::to_string(user_list.size()) + " users' authority level updated.";
            return num;
        }
        catch (const std::exception &e)
        {
            result = e.what();
            return 0;
        }
    }
}